#Sass & Compass##SassSass is a meta-language on top of CSS that's used to describe the style of a document cleanly and structurally, with more power than flat CSS allows. Sass both provides a simpler, more elegant syntax for CSS and implements various features that are useful for creating manageable style sheets.  As Sass started life in the Ruby community (Ruby is itself a programming language), much of the documentation associated with Sass has always been programmer friendly.>Sass also supports two syntaxes. The original syntax (known asSass, with files ending in a `.sass` extension) is terse and based onindentation. It removes the curly braces we're used to seeing inCSS. You can find more documentation on the indented syntax at`http://sass-lang.com/docs/yardoc/file.INDENTED_SYNTAX.html`.  >The syntax we will be using throughout this book is the SCSSbased syntax, with Sass files ending in the `.scss` extension. Thissyntax is more verbose than the original indent-based syntax butsimilar to existing CSS.##CompassThe Compass website is at `http://compass-style.org.` It describes itself as follows:      **Compass is an open-source CSS Authoring Framework.**事實上，Compass 是第一個以 Sass 為基礎的 framework。他讓 CSS3 的新效果，例如 box-shadow, gradients, columns, and transforms，都只需要但一行敘述，就可以簡單的解決跨瀏覽器的問題。###config.rbThe config.rb file is the brain of a Compass project. It defines the relationship between files and their assets, how and where the CSS should be generated, and any dependencies for a project.  `config.rb` 檔案內的內容如下：    # Require any additional compass plugins here.    # Set this to the root of your project when deployed:    http_path = "/"    css_dir = "css"    sass_dir = "sass"    images_dir = "img"    javascripts_dir = "js"    # You can select your preferred output style here (can be overridden via the command line):    # output_style = :expanded or :nested or :compact or :compressed        # To enable relative paths to assets via compass helper functions. Uncomment:    # relative_assets = true        # To disable debugging comments that display the original location of your selectors. Uncomment:    # line_comments = false>When making changes to the `config.rb` file, particularly output style, it's sometimes necessary to clear the `.sass-cache` before expected changes will be seen. In this instance, either manually delete the `sass-cache` folder and it will be recreated next time a Sass file is saved, or run the following command from the command line:  >`compass clean`  >If using the command line to watch the project for changes, rememberto start watching for changes again by running the following command:  >`compass watch`* 在開頭的`# Require any additional compass plugins here.`，下面區域可以加上我們的所需要的 plugin。例如如果需要使用 Susy Compass plugin。可以在下方寫下：  　　`require "susy"`  * 接下來的`# Set this to the root of your project when deployed:`，我們則指定了此專案內的靜態文件地址。其位置可以再特別指定        http_path = "/"        css_dir = "wp-content/themes/retlehs-roots-0e51e90/css"        sass_dir = "sass"        images_dir = "wp-content/themes/retlehs-roots-0e51e90/img"        javascripts_dir = "wp-content/themes/retlehs-roots-0e51e90/js"也可以加上自己所需要的其他元件，例如需要加上字型的檔案，可以在加上  `fonts_dir = "css/fonts"`* 下一個區域，提供編譯 CSS 後如何輸出的選項    ex. **nested** 巢狀結構            #main {            color: #999;            .content {                color: #bfbfbf;            }        }        如果修改 config.rb 的輸出設定        output_style = :nested                生成的 CSS 會如下        /* line 8, ../sass/styles.scss */        #main {            color: #999; }            /* line 10, ../sass/styles.scss */            #main .content {            color: #bfbfbf; }  ex. **compact** 緊湊結構    這個設定會把 CSS 緊縮成同一行          /* line 8, ../sass/styles.scss */        #main { color: #999; }        /* line 10, ../sass/styles.scss */        #main .content { color: #bfbfbf; }  ex. **compressed** 壓縮結構         此方式會移除所有的註解和空白字元，大多用於要產生上機用的程式碼  `#main{color:#999}#main .content{color:#bfbfbf}`  * 最後一個區域的設定，是用來設定移除註解的。使得不論是`compact`和`nested`模式都可同樣的移除註解        #main { color: #999; }        #main .content { color: #bfbfbf; }因為某些情況下，還是需要註解幫助閱讀。在註解中加上`!`，則即使是 compress 模式也可以留下註解        /*! I am loud; hear me roar */        #main {            color: #999;            .content {                color: #bfbfbf;            }        }                -->        /* I am loud; hear me roar */#main{color:#999}#main        .content{color:#bfbfbf}* 前一個區域，是用來設定相對路徑的。This setting (not enabled by default so just uncomment it) allows Compass helpers to know that if an image is specified (for example), it knows where to find it relative to the CSS (as the paths for each have already been defined).  For example, typically when writing CSS there may be a path to an image used for a background as follows:     `background-image: url('../img/image.jpg');`  I'm sure you've suffered like me; get the path wrong and no image shows up in the design. Compass eliminates this issue with a simple helper. Instead, in the Sass file we can write the following code:   `background-image: image-url('image.jpg');`    Notice the `image-url` part instead of the usual `url`? This is a little Compass helper that equates to the path specified for images in the `config.rb` file. Using this, if all a project's images were moved, it's only necessary to update the image path in the `config.rb` file, regenerate the CSS file, and all the paths will match the new setting in the output CSS.##PreprocessingSass lets you use features that don't exist in CSS yet like variables, nesting, mixins, inheritance and other nifty goodies that make writing CSS fun again.##Variables　　在 Sass 中，可以使用變數來儲存值。在檔案內重複的使用，而不用重複宣告同一份值。也可以為變數命名更有辨識度的名稱。更方便的是，也只需要在一個地方修改就可以全部都跟著變動。  　　通常變數的宣告都放在檔案開頭。其宣告語法是`$name`，以`$`為開頭。    $red: #ff0b13;    $blue: #091fff;    $green: #11c909;    .i-want-to-be-green {        color: $green;    }        $font-stack:    Helvetica, sans-serif;    $primary-color: #333;    body {        font: 100% $font-stack;        color: $primary-color;    }    ###RGBA & HSLA　　在現代最新版的瀏覽器大多支援了，RGBA 和 HSLA。但是要從其他繪圖軟體中要擷取顏色值並不總能簡單的同時拿到 hex 和 RGBA 值。在 Sass 之前的寫法都是以下：    .color-me-bad {        color: #11c909;        color: rgba(17, 201, 9, 0.9);    }但有 Sass 後可以轉換為，Sass 會自動地把值轉換成 RGBA 的值，再加上 alpha 的值 0.9。     .color-me-good {        color: $green;        color: rgba($green, 0.9);    }###Vendor prefixes　　到了 CSS3，提供了許多新功能（背景灰階、陰影和動畫等）。但是因為不同的瀏覽器的呈現不同，造成常常會有許多的前綴字，會造成許多麻煩。      .rounded {        -webkit-border-radius: 4px;        -moz-border-radius: 4px;        -ms-border-radius: 4px;        -o-border-radius: 4px;        border-radius: 4px;    }　　不過配合著 Sass 的 framework **Compass**，我們可以使用許多的**mixins**。讓我們不用記住那多負責的前綴詞，就可以達到同樣的效果    .rounded {        @include border-radius(4px);    }##Syntax在 CSS 中，ID 選擇器可能不是個好的選擇，因為如果當頁面內有重複的 ID 時，就會造成錯誤出現或是複寫。可以利用屬性選擇器的方式來替代  `[id="id-name"] {}` --> `#id-name {}`  ###Comments在 Sass 中提供了兩種方式來編寫註解。* 第一種方式，就跟一般在 CSS 中使用的方式一樣    `/* Here is a normal CSS comment */`* 第二種方式，就是單行註解。此方式有如 JavaScript 中的單行註解一樣，且此方式不會被編譯出來。    `// Here is a Sass only comment`##NestingSass will let you nest your CSS selectors in a way that follows the same visual hierarchy of your HTML. Be aware that overly nested rules will result in over-qualified CSS that could prove hard to maintain and is generally considered bad practice.  Sass 可以被允許使用巢狀結構。例如如果你想要寫一系列的`nav`元素，包含 hover 和 active 狀態，在 Sass 中你可以這樣編寫    nav {        a {            color: $red;            &:hover, &:focus {                color: $green;            }            &:visited {                color: $blue;            }        }    }此段最後會編譯成-->    nav a {        color: #ff0b13;    }    nav a:hover,    nav a:focus, {        color: #11c909;    }    nav a:visited {        color: #091fff;    }The ampersand symbol (&) 在 Sass 巢狀結構中，表示為父選擇器  It's perfect for defining pseudo classes as it effectively says 'the parent plus this pseudo element'. However, there are other ways it can work too, for example, nesting a few related selectors and expressing different relationships between them:      .main {        .content {            width: 70%;        }        .content & {            width: 100%;        }        .content & {            .two & {                color: pink;            }        }    }        --> 轉譯 CSS    .main .content {        width: 70%;    }    .content .main {        width: 100%;    }    .two .content .main {        color: pink;    }### Attribute nestingSass 也提供了 CSS 屬性的巢狀命名空間，例如 border 有 border-left, border-right, border-top 和 border-bottom。可以寫成以下：    .nesting-namespace-properties {        border: {            top: 1px dashed $color7;            right: 1px dotted $color5;            bottom: 2px solid $color8;            left: 1px solid $color4;        }    }        -->    .nesting-namespace-properties {        border-top: 1px dashed blue;        border-right: 1px dotted #007fff;        border-bottom: 2px solid #7f00ff;        border-left: 1px solid chartreuse;    }###@extend The *@extend* directive is used to extend another style. It allows any style to inherit the properties and values defined in another. Suppose there are a few elements to style that share some characteristics; they are a prime candidate for the *@extend* directive.    // Box    .box {        padding: 2em;        color: $color10;        background-color: $color11;    }    // Warning Box    .warning-box {        @extend .box;        border: 2px dotted $color1;    }    // Success Box    .success-box {        @extend .box;        border: 2px dotted $color4;    }    // Information Box    .info-box {        @extend .box;        border: 2px dotted $color7;    }        --> there is a style for the basic box, then each variation extends the box but has it's own different color border.    .box, .warning-box, .success-box, .info-box {        padding: 2em;        color: black;        background-color: white;    }    .warning-box {        border: 2px dotted red;    }    .success-box {        border: 2px dotted chartreuse;    }    .info-box {        border: 2px dotted blue;    }Sass is smart enough to group the shared styles under a single combined selector. Using the @extend directive in this manner prevents endless repetition of code for similar elements.###Placeholder We've just looked at how the *@extend* directive can extend an existing rule. However, in situations when a rule is being created purely to extend it, use a *placeholder* selector instead.    // Box    %box {        padding: 2em;        color: $color10;        background-color: $color11;    }    // Warning Box    .warning-box {        @extend %box;        border: 2px dotted $color1;    }    // Success Box    .success-box {        @extend %box;        border: 2px dotted $color4;    }    // Information Box    .info-box {        @extend %box;        border: 2px dotted $color7;    }用百分比符號(%)取代一般的選擇器，然後再用 *@extend* 來擴展-->    .warning-box, .success-box, .info-box {        padding: 2em;        color: black;        background-color: white;    }    .warning-box {        border: 2px dotted red;    }    .success-box {        border: 2px dotted chartreuse;    }    .info-box {        border: 2px dotted blue;    }##PartialsYou can create partial Sass files that contain little snippets of CSS that you can include in other Sass files. This is a great way to modularize your CSS and help keep things easier to maintain. **A partial is simply a Sass file named with a leading underscore( _ )**. You might name it something like `_partial.scss`. The underscore lets Sass know that the file is only a partial file and that it should not be generated into a CSS file. Sass partials are used with the `@import` directive.###ImportCSS has an import option that lets you split your CSS into smaller, more maintainable portions. The only drawback is that each time you use `@import` in CSS it creates another HTTP request. Sass builds on top of the current CSS `@import` but instead of requiring an HTTP request, Sass will take the file that you want to import and combine it with the file you're importing into so you can serve a single CSS file to the web browser.  Let's say you have a couple of Sass files, `_reset.scss` and `base.scss`. We want to import `_reset.scss` into `base.scss`.    // _reset.scss    html,    body,    ul,    ol {        margin: 0;        padding: 0;    }        /* base.scss */    @import 'reset';    body {        font: 100% Helvetica, sans-serif;        background-color: #efefef;    }-->    html, body, ul, ol {      margin: 0;      padding: 0;    }    body {      font: 100% Helvetica, sans-serif;      background-color: #efefef;    }##MixinsTypically, a mixin is defined once, then included elsewhere in the Sass file and passed any optional arguments. Then, on compilation, it generates the relevant code.  Some things in CSS are a bit tedious to write, especially with CSS3 and the many vendor prefixes that exist. A mixin lets you make groups of CSS declarations that you want to reuse throughout your site. You can even pass in values to make your mixin more flexible. A good use of a mixin is for vendor prefixes. Here's an example for `border-radius`.    @mixin border-radius($radius) {      -webkit-border-radius: $radius;         -moz-border-radius: $radius;          -ms-border-radius: $radius;              border-radius: $radius;    }    .box {       @include border-radius(10px);     }To create a mixin you use the `@mixin` directive and give it a name. We've named our mixin `border-radius`. We're also using the variable `$radius` inside the parentheses so we can pass in a radius of whatever we want. After you create your mixin, you can then use it as a CSS declaration starting with `@include` followed by the name of the mixin.Mixins can also be set with a default value. This means that you can include them without passing an argument and they will generate with a default value. Here's how:    @mixin bs($bs-type: border-box) {        -webkit-box-sizing: $bs-type;        -moz-box-sizing: $bs-type;        box-sizing: $bs-type;    }        * {        @include bs;    }如此之外，Sass 還可以使用 !default 還做更彈性的設定。當使用 !default 的變數，Sass 會幫忙判斷，如果沒有設定值就使用 !default 的變數。    $defined-bs-type: border-box;    $defined-bs-type: sausages !default;    @mixin bs($bs-type: $defined-bs-type) {        -webkit-box-sizing: $bs-type;        -moz-box-sizing: $bs-type;        box-sizing: $bs-type;    }        * {        @include bs;    }不管在任何地方，只要變數被設定過值，則`!default`就不會執行。所以這段會被編譯為    * {        -webkit-box-sizing: border-box;        -moz-box-sizing: border-box;        box-sizing: border-box;    }###Media queries　　在於現代的網頁上，幾乎都會加上了響應式設計。CSS 上可能寫作      @media only screen and (min-width: 280px) and (max-width: 479px) {        .h1 {            font-size: 1.1em;        }    }    @media only screen and (min-width: 480px) and (max-width: 599px) {        .h1 {            font-size: 1em;        }    }    @media only screen and (min-width: 600px) and (max-width: 767px) {        .h1 {            font-size: 0.9em;        }    }如果使用 Sass，將可以取代成-->    h1 {        @include MQ(XS) {            font-size: 1.1em;        }        @include MQ(S) {            font-size: 1em;        }        @include MQ(M) {            font-size: 0.9em;        }    }##Inheritance##Operators